##  业内常见分区规则
关系型数据库是一个二维模型，数据的切分通常就需要找到一个分区字段以确定拆分维度，再通过定义规则来实现数据库的拆分。业内的几种常见的分表规则如下：
- 基于某字段求模（Hash）
 	将求模后字段的特定范围分散到不同分区中。
- 基于日期或字段范围（Range）
  如按年拆分，2020 年一个分区，2021 年一个分区 。
  如按用户 ID 划分，0\~1000一个分表，1001\~2000 一个分表。
- 基于枚举值列表（List）
按满足某些固定条件的数据分散到不同分区中。
>?LIST和RANGE类似，区别在于LIST是枚举值列表的集合，RANGE是连续的区间值的集合。

## 各分区表规则适用场景
### RANGE规则适用场景
- 业务表数据量非常大，表存在日期或时间类型的字段
- 该字段通常不会被更新，很多查询语句都包含该字段
- 选该字段为分区键可以使得各个分区上的数据分配的比较均衡
- 可能需要定期按时间清理历史数据
 业务场景举例：用户登录日志表
- 用户每次登录都会记录登录日志
- 用户登录日志保存一年，1年后按照时间删除或者归档
- 以login_time（登录时间）为分表键

### LIST规则适用场景
- 业务表数据量非常大，存在可以按分区键取值的列表进行分区
-	同范围分区一样，各分区的列表值不能重复
-	该字段通常不会被更新，很多查询语句都包含该字段
- 每一行数据必须能找到对应的分区列表，否则数据插入失败
 业务场景举例：城市常驻人口信息表
-	以city_district（城市行政区：0 东区 1西区 2南区 3北区）为分表键
- 将不同行政区的人口信息存入对应分区进行管理

### HASH规则适用场景
无论是 Time、Range ，大部分业务场景都容易导致比较严重的数据倾斜，即分区之间负载和数据容量严重不
均衡。例如，在大部分数据库系统中，数据有明显的冷热特征——例如当前的订单被访问的概率比半年前的订单要高的多。而采用 Time 分表或 range 分表，就意味着很容易出现大部分热数据将会被路由在少数几分区中，而剩下的分区却被白白浪费掉了。而采用某个字段求模（Hash）的方案进行分区就不会出现这种问题，因为 Hash 算法的原理能够基本保证数据相对均匀的分散在不同的分区中。
业务场景举例：
商品订单表
- 以user_id（用户ID）进行HASH分区
- 用户ID是该表的主键

### KEY规则适用场景
使用场景类似HASH分区，区别在于KEY分区只支持计算一列或多列，且TDSQL服务器提供其自身的哈希函数，但是要求分区表必须有一列或多列包含整数值。
